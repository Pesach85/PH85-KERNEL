diff --git a/arch/arm/mach-omap2/dpll3xxx.c b/arch/arm/mach-omap2/dpll3xxx.c
index f77022b..81d2f9f 100644
--- a/arch/arm/mach-omap2/dpll3xxx.c
+++ b/arch/arm/mach-omap2/dpll3xxx.c
@@ -34,6 +34,8 @@ 
 #include "clock.h"
 #include "cm2xxx_3xxx.h"
 #include "cm-regbits-34xx.h"
+#include "cm-regbits-44xx.h"
+#include "cm1_44xx.h"
 
 /* CM_AUTOIDLE_PLL*.AUTO_* bit values */
 #define DPLL_AUTOIDLE_DISABLE			0x0
@@ -311,6 +313,42 @@  static int omap3_noncore_dpll_program(struct clk *clk, u16 m, u8 n, u16 freqsel)
 		__raw_writel(v, dd->control_reg);
 	}
 
+	/*
+	 * On OMAP4460, to obtain MPU DPLL frequency higher
+	 * than 1GHz, DCC (Duty Cycle Correction) needs to
+	 * be enabled.
+	 * Also the interconnect frequency to EMIF should
+	 * be switched between MPU clk divide by 4 (for
+	 * frequencies higher than 920Mhz) and MPU clk divide
+	 * by 2 (for frequencies lower than or equal to 920Mhz)
+	 * Lastly the async bridge to ABE must be MPU clk divide
+	 * by 8 for MPU clk > 748Mhz and MPU clk divide by 4
+	 * for lower frequencies.
+	 * TODO: For now use a strcmp, but need to find a
+	 * better way to identify the MPU dpll.
+	 */
+	if (cpu_is_omap446x() && !strcmp(clk->name, "dpll_mpu_ck")) {
+		/* DCC control */
+		v = __raw_readl(dd->mult_div1_reg);
+		if (dd->last_rounded_rate > 1000000000)
+			v |= OMAP4460_DCC_EN_MASK; /* Enable DCC */
+		else
+			v &= ~OMAP4460_DCC_EN_MASK; /* Disable DCC */
+		__raw_writel(v, dd->mult_div1_reg);
+
+		/* EMIF/ABE clock rate control */
+		v = __raw_readl(OMAP4430_CM_MPU_MPU_CLKCTRL);
+		if (dd->last_rounded_rate > 920000000)
+			v |= OMAP4460_CLKSEL_EMIF_DIV_MODE_MASK;
+		else
+			v &= ~OMAP4460_CLKSEL_EMIF_DIV_MODE_MASK;
+		if (dd->last_rounded_rate > 748000000)
+			v |= OMAP4460_CLKSEL_ABE_DIV_MODE_MASK;
+		else
+			v &= ~OMAP4460_CLKSEL_ABE_DIV_MODE_MASK;
+		__raw_writel(v, OMAP4430_CM_MPU_MPU_CLKCTRL);
+	}
+
 	/* Set DPLL multiplier, divider */
 	v = __raw_readl(dd->mult_div1_reg);
 	v &= ~(dd->mult_mask | dd->div1_mask);
@@ -427,6 +465,7 @@  int omap3_noncore_dpll_set_rate(struct clk *clk, unsigned long rate)
 	u16 freqsel = 0;
 	struct dpll_data *dd;
 	int ret;
+	unsigned long orig_rate = 0;
 
 	if (!clk || !rate)
 		return -EINVAL;
@@ -454,6 +493,19 @@  int omap3_noncore_dpll_set_rate(struct clk *clk, unsigned long rate)
 		if (!ret)
 			new_parent = dd->clk_bypass;
 	} else {
+		/*
+		 * On 4460, the MPU clk for frequencies higher than 1Ghz
+		 * is sourced from CLKOUTX2_M3, instead of CLKOUT_M2, while
+		 * value of M3 is fixed to 1. Hence for frequencies higher
+		 * than 1 Ghz, lock the DPLL at half the rate so the
+		 * CLKOUTX2_M3 then matches the requested rate.
+		 */
+		if (cpu_is_omap446x() && !strcmp(clk->name, "dpll_mpu_ck")
+					&& (rate > 1000000000)) {
+			orig_rate = rate;
+			rate = rate/2;
+		}
+
 		if (dd->last_rounded_rate != rate)
 			omap2_dpll_round_rate(clk, rate);
 
@@ -468,6 +520,12 @@  int omap3_noncore_dpll_set_rate(struct clk *clk, unsigned long rate)
 				WARN_ON(1);
 		}
 
+		/* Set the rate back to original for book keeping*/
+		if (orig_rate) {
+			rate = orig_rate;
+			dd->last_rounded_rate = dd->last_rounded_rate * 2;
+		}
+
 		pr_debug("clock: %s: set rate: locking rate to %lu.\n",
 			 clk->name, rate);
