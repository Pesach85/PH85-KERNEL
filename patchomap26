diff --git a/arch/arm/include/asm/cti.h b/arch/arm/include/asm/cti.h
deleted file mode 100644
index 26e7450..0000000
--- a/arch/arm/include/asm/cti.h
+++ /dev/null
@@ -1,157 +0,0 @@
-#ifndef __ASMARM_CTI_H
-#define __ASMARM_CTI_H
-
-#include <asm/io.h>
-
-/* The registers' definition is from section 3.2 of
- * Embedded Cross Trigger Revision: r0p0
- */
-#define CTICONTROL 0x000
-#define CTISTATUS 0x004
-#define CTILOCK 0x008
-#define CTIPROTECTION 0x00C
-#define CTIINTACK 0x010
-#define CTIAPPSET 0x014
-#define CTIAPPCLEAR 0x018
-#define CTIAPPPULSE 0x01c
-#define CTIINEN 0x020
-#define CTIOUTEN 0x0A0
-#define CTITRIGINSTATUS 0x130
-#define CTITRIGOUTSTATUS 0x134
-#define CTICHINSTATUS 0x138
-#define CTICHOUTSTATUS 0x13c
-#define CTIPERIPHID0 0xFE0
-#define CTIPERIPHID1 0xFE4
-#define CTIPERIPHID2 0xFE8
-#define CTIPERIPHID3 0xFEC
-#define CTIPCELLID0 0xFF0
-#define CTIPCELLID1 0xFF4
-#define CTIPCELLID2 0xFF8
-#define CTIPCELLID3 0xFFC
-
-/* The below are from section 3.6.4 of
- * CoreSight v1.0 Architecture Specification
- */
-#define LOCKACCESS 0xFB0
-#define LOCKSTATUS 0xFB4
-
-/* write this value to LOCKACCESS will unlock the module, and
- * other value will lock the module
- */
-#define LOCKCODE 0xC5ACCE55
-
-/**
- * struct cti - cross trigger interface struct
- * @base: mapped virtual address for the cti base
- * @irq: irq number for the cti
- * @trig_out_for_irq: triger out number which will cause
- * the @irq happen
- *
- * cti struct used to operate cti registers.
- */
-struct cti {
- void __iomem *base;
- int irq;
- int trig_out_for_irq;
-};
-
-/**
- * cti_init - initialize the cti instance
- * @cti: cti instance
- * @base: mapped virtual address for the cti base
- * @irq: irq number for the cti
- * @trig_out: triger out number which will cause
- * the @irq happen
- *
- * called by machine code to pass the board dependent
- * @base, @irq and @trig_out to cti.
- */
-static inline void cti_init(struct cti *cti,
- void __iomem *base, int irq, int trig_out)
-{
- cti->base = base;
- cti->irq  = irq;
- cti->trig_out_for_irq = trig_out;
-}
-
-/**
- * cti_map_trigger - use the @chan to map @trig_in to @trig_out
- * @cti: cti instance
- * @trig_in: trigger in number
- * @trig_out: trigger out number
- * @channel: channel number
- *
- * This function maps one trigger in of @trig_in to one trigger
- * out of @trig_out using the channel @chan.
- */
-static inline void cti_map_trigger(struct cti *cti,
- int trig_in, int trig_out, int chan)
-{
- void __iomem *base = cti->base;
-
- __raw_writel(BIT(chan), base + CTIINEN + trig_in * 4);
- __raw_writel(BIT(chan), base + CTIOUTEN + trig_out * 4);
-}
-
-/**
- * cti_enable - enable the cti module
- * @cti: cti instance
- *
- * enable the cti module
- */
-static inline void cti_enable(struct cti *cti)
-{
- __raw_writel(0x1, cti->base + CTICONTROL);
-}
-
-/**
- * cti_disable - disable the cti module
- * @cti: cti instance
- *
- * enable the cti module
- */
-static inline void cti_disable(struct cti *cti)
-{
- __raw_writel(0, cti->base + CTICONTROL);
-}
-
-/**
- * cti_irq_ack - clear the cti irq
- * @cti: cti instance
- *
- * clear the cti irq
- */
-static inline void cti_irq_ack(struct cti *cti)
-{
- void __iomem *base = cti->base;
- unsigned long val;
-
- val = __raw_readl(base + CTIINTACK);
- val |= BIT(cti->trig_out_for_irq);
- __raw_writel(val, base + CTIINTACK);
-}
-
-/**
- * cti_unlock - unlock cti module
- * @cti: cti instance
- *
- * unlock the cti module, or else any writes to the cti
- * module is not allowed.
- */
-static inline void cti_unlock(struct cti *cti)
-{
- __raw_writel(LOCKCODE, cti->base + LOCKACCESS);
-}
-
-/**
- * cti_lock - lock cti module
- * @cti: cti instance
- *
- * lock the cti module, so any writes to the cti
- * module will be not allowed.
- */
-static inline void cti_lock(struct cti *cti)
-{
- __raw_writel(~LOCKCODE, cti->base + LOCKACCESS);
-}
-#endif
diff --git a/arch/arm/include/asm/pmu.h b/arch/arm/include/asm/pmu.h
index 90114fa..665ef2c 100644
--- a/arch/arm/include/asm/pmu.h
+++ b/arch/arm/include/asm/pmu.h
@@ -27,22 +27,13 @@ enum arm_pmu_type {
 /*
  * struct arm_pmu_platdata - ARM PMU platform data
  *
- * @handle_irq: an optional handler which will be called from the
- * interrupt and passed the address of the low level handler,
- * and can be used to implement any platform specific handling
- * before or after calling it.
- * @enable_irq: an optional handler which will be called after
- * request_irq and be used to handle some platform specific
- * irq enablement
- * @disable_irq: an optional handler which will be called before
- * free_irq and be used to handle some platform specific
- * irq disablement
+ * @handle_irq: an optional handler which will be called from the interrupt and
+ * passed the address of the low level handler, and can be used to implement
+ * any platform specific handling before or after calling it.
  */
 struct arm_pmu_platdata {
  irqreturn_t (*handle_irq)(int irq, void *dev,
   irq_handler_t pmu_handler);
- void (*enable_irq)(int irq);
- void (*disable_irq)(int irq);
 };
 
 #ifdef CONFIG_CPU_HAS_PMU
diff --git a/arch/arm/kernel/perf_event.c b/arch/arm/kernel/perf_event.c
index 6984a47..ecebb89 100644
--- a/arch/arm/kernel/perf_event.c
+++ b/arch/arm/kernel/perf_event.c
@@ -374,7 +374,6 @@ armpmu_release_hardware(struct arm_pmu *armpmu)
 {
  int i, irq, irqs;
  struct platform_device *pmu_device = armpmu->plat_device;
- struct arm_pmu_platdata *plat = dev_get_platdata(&pmu_device->dev);
 
  irqs = min(pmu_device->num_resources, num_possible_cpus());
 
@@ -382,11 +381,8 @@ armpmu_release_hardware(struct arm_pmu *armpmu)
  if (!cpumask_test_and_clear_cpu(i, &armpmu->active_irqs))
  continue;
  irq = platform_get_irq(pmu_device, i);
- if (irq >= 0) {
- if (plat->disable_irq)
- plat->disable_irq(irq);
+ if (irq >= 0)
  free_irq(irq, armpmu);
- }
  }
 
  release_pmu(armpmu->type);
@@ -447,8 +443,6 @@ armpmu_reserve_hardware(struct arm_pmu *armpmu)
  armpmu_release_hardware(armpmu);
  return err;
  }
- if (plat->enable_irq)
- plat->enable_irq(irq);
 
  cpumask_set_cpu(i, &armpmu->active_irqs);
  }
diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index fdd3538..2e2cbaf 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -26,7 +26,6 @@
 #include <asm/mach-types.h>
 #include <asm/mach/map.h>
 #include <asm/pmu.h>
-#include <asm/cti.h>
 
 #include <plat/tc.h>
 #include <plat/board.h>
@@ -583,93 +582,19 @@ static struct resource omap3_pmu_resource = {
  .flags = IORESOURCE_IRQ,
 };
 
-static struct resource omap4_pmu_resource[] = {
- {
- .start = OMAP44XX_IRQ_CTI0,
- .end = OMAP44XX_IRQ_CTI0,
- .flags = IORESOURCE_IRQ,
- },
- {
- .start = OMAP44XX_IRQ_CTI1,
- .end = OMAP44XX_IRQ_CTI1,
- .flags = IORESOURCE_IRQ,
- }
-};
-
 static struct platform_device omap_pmu_device = {
  .name = "arm-pmu",
  .id = ARM_PMU_DEVICE_CPU,
  .num_resources = 1,
 };
 
-static struct arm_pmu_platdata omap4_pmu_data;
-static struct cti omap4_cti[2];
-
-static void omap4_enable_cti(int irq)
-{
- if (irq == OMAP44XX_IRQ_CTI0)
- cti_enable(&omap4_cti[0]);
- else if (irq == OMAP44XX_IRQ_CTI1)
- cti_enable(&omap4_cti[1]);
-}
-
-static void omap4_disable_cti(int irq)
-{
- if (irq == OMAP44XX_IRQ_CTI0)
- cti_disable(&omap4_cti[0]);
- else if (irq == OMAP44XX_IRQ_CTI1)
- cti_disable(&omap4_cti[1]);
-}
-
-static irqreturn_t omap4_pmu_handler(int irq, void *dev, irq_handler_t handler)
-{
- if (irq == OMAP44XX_IRQ_CTI0)
- cti_irq_ack(&omap4_cti[0]);
- else if (irq == OMAP44XX_IRQ_CTI1)
- cti_irq_ack(&omap4_cti[1]);
-
- return handler(irq, dev);
-}
-
-static void omap4_configure_pmu_irq(void)
-{
- void __iomem *base0;
- void __iomem *base1;
-
- base0 = ioremap(OMAP44XX_CTI0_BASE, SZ_4K);
- base1 = ioremap(OMAP44XX_CTI1_BASE, SZ_4K);
- if (!base0 && !base1) {
- pr_err("ioremap for OMAP4 CTI failed\n");
- return;
- }
-
- /*configure CTI0 for pmu irq routing*/
- cti_init(&omap4_cti[0], base0, OMAP44XX_IRQ_CTI0, 6);
- cti_unlock(&omap4_cti[0]);
- cti_map_trigger(&omap4_cti[0], 1, 6, 2);
-
- /*configure CTI1 for pmu irq routing*/
- cti_init(&omap4_cti[1], base1, OMAP44XX_IRQ_CTI1, 6);
- cti_unlock(&omap4_cti[1]);
- cti_map_trigger(&omap4_cti[1], 1, 6, 2);
-
- omap4_pmu_data.handle_irq = omap4_pmu_handler;
- omap4_pmu_data.enable_irq = omap4_enable_cti;
- omap4_pmu_data.disable_irq = omap4_disable_cti;
-}
-
 static void omap_init_pmu(void)
 {
  if (cpu_is_omap24xx())
  omap_pmu_device.resource = &omap2_pmu_resource;
  else if (cpu_is_omap34xx())
  omap_pmu_device.resource = &omap3_pmu_resource;
- else if (cpu_is_omap44xx()) {
- omap_pmu_device.resource = omap4_pmu_resource;
- omap_pmu_device.num_resources = 2;
- omap_pmu_device.dev.platform_data = &omap4_pmu_data;
- omap4_configure_pmu_irq();
- } else
+ else
  return;
 
  platform_device_register(&omap_pmu_device);
diff --git a/arch/arm/plat-omap/include/plat/omap44xx.h b/arch/arm/plat-omap/include/plat/omap44xx.h
index 2408034..e8250d0 100644
--- a/arch/arm/plat-omap/include/plat/omap44xx.h
+++ b/arch/arm/plat-omap/include/plat/omap44xx.h
@@ -72,8 +72,5 @@
 #define OMAP44XX_HSUSB_OHCI_BASE (L4_44XX_BASE + 0x64800)
 #define OMAP44XX_HSUSB_EHCI_BASE (L4_44XX_BASE + 0x64C00)
 
-#define OMAP44XX_CTI0_BASE 0x54148000
-#define OMAP44XX_CTI1_BASE 0x54149000
-
 #endif /* __ASM_ARCH_OMAP44XX_H */
  
