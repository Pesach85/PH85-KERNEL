diff --git arch/arm/mach-omap2/id.c arch/arm/mach-omap2/id.c
index 23612b2..a90630d 100644
--- arch/arm/mach-omap2/id.c
+++ arch/arm/mach-omap2/id.c
@@ -246,7 +246,6 @@ static void __init omap4_check_features(void)
 			break;
 		case 1:
 		default:
-			omap4_features |= OMAP4_HAS_MPU_1_5GHZ;
 			/* Standard device */
 			omap4_features |= OMAP4_HAS_MPU_1_2GHZ;
 			break;
diff --git arch/arm/mach-omap2/omap2plus-cpufreq.c arch/arm/mach-omap2/omap2plus-cpufreq.c
index dd1dcc7..6c1261c 100644
--- arch/arm/mach-omap2/omap2plus-cpufreq.c
+++ arch/arm/mach-omap2/omap2plus-cpufreq.c
@@ -421,114 +421,9 @@ struct freq_attr omap_cpufreq_attr_screen_off_freq = {
 	.store = store_screen_off_freq,
 };
 
-/*
- * OMAP4 MPU voltage control via cpufreq by Michael Huang (coolbho3k)
- *
- * Note: Each opp needs to have a discrete entry in both volt data and
- * dependent volt data (in opp4xxx_data.c), or voltage control breaks. Make a
- * new voltage entry for each opp. Keep this in mind when adding extra
- * frequencies.
- */
-
-/* struct opp is defined elsewhere, but not in any accessible header files */
-struct opp {
-        struct list_head node;
-
-        bool available;
-        unsigned long rate;
-        unsigned long u_volt;
-
-        struct device_opp *dev_opp;
-};
-
-static ssize_t show_uv_mv_table(struct cpufreq_policy *policy, char *buf)
-{
-	int i = 0;
-	unsigned long volt_cur;
-	char *out = buf;
-	struct opp *opp_cur;
-
-	/* Reverse order sysfs entries for consistency */
-	while(freq_table[i].frequency != CPUFREQ_TABLE_END)
-                i++;
-
-	/* For each entry in the cpufreq table, print the voltage */
-	for(i--; i >= 0; i--) {
-		if(freq_table[i].frequency != CPUFREQ_ENTRY_INVALID) {
-			/* Find the opp for this frequency */
-			opp_cur = opp_find_freq_exact(mpu_dev,
-				freq_table[i].frequency*1000, true);
-			/* sprint the voltage (mV)/frequency (MHz) pairs */
-			volt_cur = opp_cur->u_volt;
-			out += sprintf(out, "%umhz: %lu mV\n",
-				freq_table[i].frequency/1000, volt_cur/1000);
-		}
-	}
-        return out-buf;
-}
-
-static ssize_t store_uv_mv_table(struct cpufreq_policy *policy,
-	const char *buf, size_t count)
-{
-	int i = 0;
-	unsigned long volt_cur, volt_old;
-	int ret;
-	char size_cur[16];
-	struct opp *opp_cur;
-	struct voltagedomain *mpu_voltdm;
-	mpu_voltdm = voltdm_lookup("mpu");
-
-	while(freq_table[i].frequency != CPUFREQ_TABLE_END)
-		i++;
-
-	for(i--; i >= 0; i--) {
-		if(freq_table[i].frequency != CPUFREQ_ENTRY_INVALID) {
-			ret = sscanf(buf, "%lu", &volt_cur);
-			if(ret != 1) {
-				return -EINVAL;
-			}
-
-			/* Alter voltage. First do it in our opp */
-			opp_cur = opp_find_freq_exact(mpu_dev,
-				freq_table[i].frequency*1000, true);
-			opp_cur->u_volt = volt_cur*1000;
-
-			/* Then we need to alter voltage domains */
-			/* Save our old voltage */
-			volt_old = mpu_voltdm->vdd->volt_data[i].volt_nominal;
-			/* Change our main and dependent voltage tables */
-			mpu_voltdm->vdd->
-				volt_data[i].volt_nominal = volt_cur*1000;
-			mpu_voltdm->vdd->dep_vdd_info->
-				dep_table[i].main_vdd_volt = volt_cur*1000;
-
-			/* Alter current voltage in voltdm, if appropriate */
-			if(volt_old == mpu_voltdm->curr_volt) {
-				mpu_voltdm->curr_volt = volt_cur*1000;
-			}
-
-			/* Non-standard sysfs interface: advance buf */
-			ret = sscanf(buf, "%s", size_cur);
-			buf += (strlen(size_cur)+1);
-		}
-		else {
-			pr_err("%s: frequency entry invalid for %u\n",
-				__func__, freq_table[i].frequency);
-		}
-	}
-	return count;
-}
-
-static struct freq_attr omap_uv_mv_table = {
-	.attr = {.name = "UV_mV_table", .mode=0644,},
-	.show = show_uv_mv_table,
-	.store = store_uv_mv_table,
-};
-
 static struct freq_attr *omap_cpufreq_attr[] = {
 	&cpufreq_freq_attr_scaling_available_freqs,
 	&omap_cpufreq_attr_screen_off_freq,
-	&omap_uv_mv_table,
 	NULL,
 };
 
diff --git arch/arm/mach-omap2/opp4xxx_data.c arch/arm/mach-omap2/opp4xxx_data.c
index 591335a..c0fd100 100644
--- arch/arm/mach-omap2/opp4xxx_data.c
+++ arch/arm/mach-omap2/opp4xxx_data.c
@@ -157,14 +157,12 @@ static struct omap_opp_def __initdata omap443x_opp_def_list[] = {
 #define OMAP4460_VDD_MPU_OPP100_UV		1203000
 #define OMAP4460_VDD_MPU_OPPTURBO_UV		1317000
 #define OMAP4460_VDD_MPU_OPPNITRO_UV		1380000
-#define OMAP4460_VDD_MPU_OPPOC_UV		1380000
 
 struct omap_volt_data omap446x_vdd_mpu_volt_data[] = {
 	VOLT_DATA_DEFINE(OMAP4460_VDD_MPU_OPP50_UV, OMAP44XX_CONTROL_FUSE_MPU_OPP50, 0xf4, 0x0c, OMAP_ABB_NOMINAL_OPP),
 	VOLT_DATA_DEFINE(OMAP4460_VDD_MPU_OPP100_UV, OMAP44XX_CONTROL_FUSE_MPU_OPP100, 0xf9, 0x16, OMAP_ABB_NOMINAL_OPP),
 	VOLT_DATA_DEFINE(OMAP4460_VDD_MPU_OPPTURBO_UV, OMAP44XX_CONTROL_FUSE_MPU_OPPTURBO, 0xfa, 0x23, OMAP_ABB_NOMINAL_OPP),
 	VOLT_DATA_DEFINE(OMAP4460_VDD_MPU_OPPNITRO_UV, OMAP44XX_CONTROL_FUSE_MPU_OPPNITRO, 0xfa, 0x27, OMAP_ABB_FAST_OPP),
-	VOLT_DATA_DEFINE(OMAP4460_VDD_MPU_OPPOC_UV, OMAP44XX_CONTROL_FUSE_MPU_OPPNITRO, 0xfa, 0x27, OMAP_ABB_FAST_OPP),
 	VOLT_DATA_DEFINE(0, 0, 0, 0, 0),
 };
 
@@ -198,7 +196,6 @@ static struct omap_vdd_dep_volt omap446x_vdd_mpu_core_dep_data[] = {
 	{.main_vdd_volt = OMAP4460_VDD_MPU_OPP100_UV, .dep_vdd_volt = OMAP4460_VDD_CORE_OPP100_UV},
 	{.main_vdd_volt = OMAP4460_VDD_MPU_OPPTURBO_UV, .dep_vdd_volt = OMAP4460_VDD_CORE_OPP100_UV},
 	{.main_vdd_volt = OMAP4460_VDD_MPU_OPPNITRO_UV, .dep_vdd_volt = OMAP4460_VDD_CORE_OPP100_UV},
-	{.main_vdd_volt = OMAP4460_VDD_MPU_OPPOC_UV, .dep_vdd_volt = OMAP4460_VDD_CORE_OPP100_UV},
 };
 
 struct omap_vdd_dep_info omap446x_vddmpu_dep_info[] = {
@@ -236,7 +233,7 @@ static struct omap_opp_def __initdata omap446x_opp_def_list[] = {
 	/* MPU OPP4 - OPP-Nitro */
 	OPP_INITIALIZER("mpu", "virt_dpll_mpu_ck", "mpu", false, 1200000000, OMAP4460_VDD_MPU_OPPNITRO_UV),
 	/* MPU OPP4 - OPP-Nitro SpeedBin */
-	OPP_INITIALIZER("mpu", "virt_dpll_mpu_ck", "mpu", false, 1400000000, OMAP4460_VDD_MPU_OPPOC_UV),
+	OPP_INITIALIZER("mpu", "virt_dpll_mpu_ck", "mpu", false, 1500000000, OMAP4460_VDD_MPU_OPPNITRO_UV),
 	/* L3 OPP1 - OPP50 */
 	OPP_INITIALIZER("l3_main_1", "virt_l3_ck", "core", true, 100000000, OMAP4460_VDD_CORE_OPP50_UV),
 	/* L3 OPP2 - OPP100 */
@@ -263,7 +260,7 @@ static struct omap_opp_def __initdata omap446x_opp_def_list[] = {
 	/* SGX OPP2 - OPP100 */
 	OPP_INITIALIZER("gpu", "dpll_per_m7x2_ck", "core", true, 307200000, OMAP4460_VDD_CORE_OPP100_UV),
 	/* SGX OPP3 - OPPOV */
-	OPP_INITIALIZER("gpu", "dpll_per_m7x2_ck", "core", true, 384000000, OMAP4460_VDD_CORE_OPP100_OV_UV),
+	OPP_INITIALIZER("gpu", "dpll_per_m7x2_ck", "core", false, 384000000, OMAP4460_VDD_CORE_OPP100_OV_UV),
 	/* FDIF OPP1 - OPP25 */
 	OPP_INITIALIZER("fdif", "fdif_fck", "core", true, 32000000, OMAP4460_VDD_CORE_OPP50_UV),
 	/* FDIF OPP2 - OPP50 */
@@ -327,9 +324,9 @@ int __init omap4_opp_init(void)
 	if (!r) {
 		if (omap4_has_mpu_1_2ghz())
 			omap4_mpu_opp_enable(1200000000);
-		/* Overclocked OPP */
-		if (omap4_has_mpu_1_5ghz())
-			omap4_mpu_opp_enable(1400000000);
+		/* The tuna PCB doesn't support 1.5GHz, so disable it for now */
+		/*if (omap4_has_mpu_1_5ghz())
+			omap4_mpu_opp_enable(1500000000);*/
 	}
 
 	return r;

